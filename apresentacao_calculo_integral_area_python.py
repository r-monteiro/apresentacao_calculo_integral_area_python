# -*- coding: utf-8 -*-
"""TRABALHO ANDRÉ - ROSE.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1egLfN0KloSBtY5ZQ9dWUtaplFqz6RqYD
"""

def f(x):
    # Defina aqui a sua função
    return x ** 2  # Exemplo: f(x) = x^2

def calcular_area(funcao, a, b, n):
    """Calcula a área sob a função no intervalo [a, b] usando a Regra dos Trapézios com n subintervalos."""
    h = (b - a) / n  # Tamanho de cada subintervalo
    soma = 0

    for i in range(n):
        x0 = a + i * h  # Ponto inicial do subintervalo
        x1 = x0 + h     # Ponto final do subintervalo
        area_subintervalo = (funcao(x0) + funcao(x1)) * h / 2  # Área do subintervalo pela Regra dos Trapézios
        soma += area_subintervalo

    return soma

# Exemplo de uso:
a = 0  # Início do intervalo
b = 2  # Fim do intervalo
n = 1000  # Número de subintervalos

area = calcular_area(f, a, b, n)
print("A área sob a curva é:", area)

from sympy import symbols, integrate

# Solicita a função do usuário
funcao = input("Digite a função (em termos de x): ")

# Solicita o intervalo de integração
a = float(input("Digite o limite inferior do intervalo: "))
b = float(input("Digite o limite superior do intervalo: "))

# Define a variável simbólica
x = symbols('x')

# Calcula a integral definida da função
integral = integrate(funcao, (x, a, b))

print("A integral definida de", funcao, "no intervalo [", a, ",", b, "] é:", integral)

import numpy as np
import matplotlib.pyplot as plt
from sympy import symbols, lambdify, integrate

# Solicita a função do usuário
funcao = input("Digite a função (em termos de x): ")

# Solicita o intervalo de integração
a = float(input("Digite o limite inferior do intervalo: "))
b = float(input("Digite o limite superior do intervalo: "))

# Define a variável simbólica
x = symbols('x')

# Calcula a integral definida da função
integral = integrate(funcao, (x, a, b))

# Converte a função para uma função numérica
funcao_numeric = lambdify(x, funcao)

# Gera valores x para o gráfico
x_vals = np.linspace(a, b, 100)
# Calcula os valores y correspondentes
y_vals = funcao_numeric(x_vals)

# Plota o gráfico da função
plt.plot(x_vals, y_vals, label=funcao)
plt.fill_between(x_vals, y_vals, 0, where=(x_vals >= a) & (x_vals <= b), alpha=0.3)
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Gráfico da Função')
plt.legend()
plt.grid(True)
plt.show()

print("A integral definida de", funcao, "no intervalo [", a, ",", b, "] é:", integral)

import numpy as np
import matplotlib.pyplot as plt

def f(x):
    return x**(1/2)

# Intervalo de integração
a = 0  # Início do intervalo
b = 2  # Fim do intervalo

# Gera valores x para o gráfico
x_vals = np.linspace(a, b, 100)
# Calcula os valores y correspondentes
y_vals = f(x_vals)

# Plota o gráfico da função
plt.plot(x_vals, y_vals, label='f(x) = x^3')
plt.fill_between(x_vals, y_vals, 0, where=(x_vals >= a) & (x_vals <= b), alpha=0.3)
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Gráfico da Função')
plt.legend()
plt.grid(True)
plt.show()

# Cálculo da área utilizando o método do trapézio
n = 1000  # Número de subintervalos
h = (b - a) / n  # Tamanho de cada subintervalo

soma = 0.5 * (f(a) + f(b))  # Inicializa a soma com os valores extremos

for i in range(1, n):
    xi = a + i * h  # Calcula o valor de x para cada subintervalo
    soma += f(xi)  # Adiciona o valor da função ao somatório

area = h * soma

print("A área sob a curva é:", area)

# Importa a biblioteca "NumPy" e a sub-biblioteca do matplotlib "pyplot".
import numpy as np
import matplotlib.pyplot as plt

# Define uma função 'f' que recebe "x, m, b" como argumentos.
# Essa função calcula e retorna o valor de uma função m * x + b.
def f(x, m, b):
    return m * x + b

# Solicita os coeficientes da reta
m = float(input("Digite o coeficiente angular 'm' da reta: "))
b = float(input("Digite o coeficiente linear 'b' da reta: "))

# Intervalo de plotagem
inicio = float(input("Digite o limite inferior do intervalo: "))
fim = float(input("Digite o limite superior do intervalo: "))

# Gera 100 valores igualmente espaçados no intervalo "inicio" e "fim" (eixo x) utilizando a função 'linspace' do Numpy.
x_vals = np.linspace(inicio, fim, 100)
# Calcula os valores de 'y' correspondentes a cada valor de 'x' em "x_vals" usando a função 'f' definida anteriormente.
y_vals = f(x_vals, m, b)

# Plota o gráfico da reta
plt.plot(x_vals, y_vals, label='f(x) = {}x + {}'.format(m, b)) # Legenda do gráfico.
plt.fill_between(x_vals, y_vals, 0, where=(x_vals >= inicio) & (x_vals <= fim), alpha=0.3) # Preenchimento do gráfico.
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Gráfico de uma Reta')
plt.legend()
plt.grid(True)
plt.show()

# Cálculo da área utilizando o método do trapézio
n = 1000  # Número de subintervalos
h = (fim - inicio) / n  # Define o tamanho de cada subintervalo 'h'.

soma = 0.5 * (f(inicio, m, b) + f(fim, m, b))  # Inicializa a soma com os valores extremos

for i in range(1, n): # Loop de '1' até 'n-1'.
    xi = inicio + i * h  # Calcula o valor de x para cada subintervalo
    soma += f(xi, m, b)  # Adiciona o valor da função ao somatório

area = h * soma

print("A área sob a reta é:", area)

# Importa a biblioteca "NumPy" e a sub-biblioteca do matplotlib "pyplot".
import numpy as np
import matplotlib.pyplot as plt

# Define uma função 'f' que recebe "x, a, b, c" como argumentos.
# Essa função calcula e retorna o valor de uma função quadrática a * x**2 + b * x + c.
def f(x, a, b, c):
    return a * x**2 + b * x + c

# Solicita os coeficientes da função quadrática
a = float(input("Digite o coeficiente 'a' da função quadrática: "))
b = float(input("Digite o coeficiente 'b' da função quadrática: "))
c = float(input("Digite o coeficiente 'c' da função quadrática: "))

# Intervalo de integração
inicio = float(input("Digite o limite inferior do intervalo: "))
fim = float(input("Digite o limite superior do intervalo: "))

# Gera 100 valores igualmente espaçados no intervalo "inicio" e "fim" (eixo x) utilizando a função 'linspace' do Numpy.
x_vals = np.linspace(inicio, fim, 100)
# Calcula os valores de 'y' correspondentes a cada valor de 'x' em "x_vals" usando a função 'f' definida anteriormente.
y_vals = f(x_vals, a, b, c)

# Plota o gráfico da função
plt.plot(x_vals, y_vals, label='f(x) = {}x^2 + {}x + {}'.format(a, b, c)) # Legenda do gráfico.
plt.fill_between(x_vals, y_vals, 0, where=(x_vals >= inicio) & (x_vals <= fim), alpha=0.3) # Preenchimento do gráfico.
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Gráfico da Função Quadrática')
plt.legend()
plt.grid(True)
plt.show()

# Cálculo da área utilizando o método do trapézio
n = 1000  # Número de subintervalos
h = (fim - inicio) / n  # Define o tamanho de cada subintervalo 'h'.

soma = 0.5 * (f(inicio, a, b, c) + f(fim, a, b, c))  # Inicializa a variável com a soma dos valores extremos.

for i in range(1, n): #  Inicia um loop que repete de '1' até 'n - 1'.
    xi = inicio + i * h  # Calcula o valor de x para cada subintervalo.
    soma += f(xi, a, b, c)  # Adiciona o valor da função ao somatório 'soma'.

area = h * soma # Calcula a área sob a curva da função quadrática multiplicando o tamanho do subintervalo 'h' pelo somatório 'soma'.

print("A área sob a curva é:", area)